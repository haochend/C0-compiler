(* README

Author: Frank Pfenning fp@cs.cmu.edu
Modified: Anand Subramanian asubrama@andrew.cmu.edu
Modified for OCaml from SML: Michael Duggan md5i@cs.cmu.edu
Modified: Alice Rao alrao@andrew.cmu.edu
Modified: David Dong haochend@andrew.cmu.edu
Modified: Jin Yan jyan1@andrew.cmu.edu *)
Welcome to 15-411!
This is some starter code for the L1 compiler you have to build for the Lab1. It contains a lexer, parser, translator, and even a code generator, except that the code generator creates pseudo assembly language with fictitious instructions and an unlimited number of registers. We took some care to use good style (according to the instructor); you may consider this a model for your own coding. Feel free to modify any and all of this code as you see fit.

Bug reports to the course staff are particularly welcome and will be noted in the extra credit category.

OCaml Notes
This starter code assumes OCaml 4.05.0, the version available on the autograder. You should ensure that you are using this version by running opam switch 4.05.0. The starter code uses the Jane Street Core standard library replacement, which you can install using OPAM URL:https://opam.ocaml.org/doc/Install.html with opam install core.

For information on the OCaml Standard Library, ocamllex, ocamlyacc, and other sundry details, see URL:http://caml.inria.fr/pub/docs/manual-ocaml-4.05/index.html.

Source Files
The following are the source files for the L1 compiler

README -- this file

Makefile -- makefile for the compiler For a quick test

% make          (generates file bin/c0c)
% bin/c0c --verbose ../tests0/return01.l1.

                should generate ../tests0/test1.s in pseudo assembly

% make clean        (removes generated files)
bin/c0c -- the native executable generated by OCaml

top/ Toplevel stuff top.ml This is the main driver. It calls all the other parts of the compiler.

parse/ lexing and parsing ast.ml abstract syntax tree for the l1 language c0Lexer.mll lexer for l1 (ocamllex file) c0Parser.mly parser for l1 (ocamlyacc file) parse.ml code that sets up and calls the parser/lexer parseState.ml some utility code for the parser

type/ type checking typeChecker.ml basic type checker over the ast

trans/ translation to IR tree.ml data structure representing the IR tree trans.ml converts from the AST to the IR tree temp.ml generates temporary variables on the fly

codegen/ conversion to assembly assem.ml representation of assembly used by the compiler codegen.ml generates pseudo-assembly with temporaries from IR

util/ errorMsg.ml error message utilities mark.ml library for tracking source file positions symbol.ml symbol table library

graph/ apply.ml applies the coloring to assem generated by instruction select liveness.ml analyze the assem to get liveness of temps in lines regalloc.ml generate the coloring from liveness analysis

Debugging Hints
"make debug" will generate a debuggable bytecode version of the compiler named "go.d.byte". You can run this in the OCaml debugger:

ocamldebug go.d.byte set arguments ../tests0/return01.l1 step

The debugger is a time-travelling debugger. It allows you to step backwards as well as forwards. See the OCaml manual for more information.

You can use

./go.d.byte --verbose --dump-ast --dump-ir --dump-assem file.l1;
to print information from all the phases of the current compiler.

You can use

./go.d.byte "--debug-parse file.l1";
to get a debug trace of the parser.

To get a state table for the parser, you can run

ocamlyacc -v parse/c0Parser.mly
This will generate a "parse/c0Parser.output" file which contains information about the parse states. Remove the generated c0Parser.ml and c0Parser.mli files before recompiling, as they will confuse ocamlbuild. (Try it and see. It is safe.)

Lab1 checkpoint
We finished the register allocation and liveness analysis. The liveness analysis just covers the straight line part with no other rules working for control flow. We also finished the register spilling and achieved a pretty good pass rate with just spilling but would memory overflow in some tests. As a result, we commit now to just use spilling without register allocation.

The typechecker remained unchanged. We set up a rule for not using r11 in register usage to save it for spilling usage and when we encounter a temp which should be in stack, we check it and use rbp to find its place.

In addition, MOD and DIV calculation needs eax and ecx to take one of the operand and store the result after calculation.

Lab2 checkpoint
In lab2, we add control logic to the grammar and we also need to modify the typeChecker.

We also add a lot of operations such as binops, asnops and unops. We did elaboration process mostly right after something is parsed in the parser level where when we see a for loop we would change it to a while loop or asnop and post operations, we would directly elaborate it into a binop operation.

We changed the data structure of the AST, it used to be a list of stms in lab1. Now we changed it to a tree structure, where all the branchings are basically a Seq.

We add a new type bool, but it was mainly for the purpose of typechecking. After that, it basically performs the corresponding legal operations for bool type as int for other operations. Also, we have taken care of associativity and precedence of all the operands in parser level. Thus, in the typechecker, the main issues were checking compatible types and scoping. For types, the data of each key in the symbol map now contains a type, and tc_exp now takes an argument type to check whether the evaluated type is compatible with the given type. For the scoping issue, we mostly follow the instructions in the writeup, with one exception of having a block type as one of the statements in order to take care of checking for block is the first half of seq.

We create another label class similar to TEMP which also counts from 0 and tags all labels in assembly code. Labels are created when we need to translate a condition or a loop.

We also tried to optimized the register allocation and liveness analysis. We were only able to achieve minor improvements.

Lab3 checkpoint
We transferred the program to a list of gdecls and evaluate them separately, like how we did with stms in lab 1. For the purpose of this lab, we have function definition, function declaration, main function definition, main function declaration and new type definition as gdecls. The structure of a single function basically remains unchanged from lab 2.

We created another argument class that prioritize register usage from EDI. Since we reset the counter for TEMPs at the start of every gdecls and register arguments into environment env before evaluating function body, arguements are automatically connected to Temps inside function.

In testing, we found out that when we trying to enter a function, rsp need to mod 16 by 8 which should be handled in the caller. Caller saved registers are handled before function call and callee saved registers are handled after entering the function.

When we were implementing function calls, it's worth noted that for external function calls, linux system is different from Mac system that Mac system need to add underscore before function names, such as callq _abort.

To correctly handle the stack for calling convention, we keep track of the largest number Temp uses and pass it into every returns such that it can clear the correct amount of stack before return.

With respect to header file, we parse the header file the same way as the the source file before doing the typechecking. In the typechecking process, we would first pass in the header file and then pass the result function map and type map into the typechecker of the source file. The main issues for this lab is to check the return types, handling name shadowing and processing parameters and arguments. We check the return types similar to what we did with the tc_exp, by passing in a return type to tc_stms and also check the return value of tc_stms to compare it with the type of the function. Name shadowing is simply checking variable map, function map, and type map whenever we encounter new IDENT. For processing parameter and arguments, we simply compare the corresponding types, and also add the arguments into variable map when we do the type checking of a function definition.