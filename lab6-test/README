(* README
 * Author: Frank Pfenning <fp@cs.cmu.edu>
 * Modified: Anand Subramanian <asubrama@andrew.cmu.edu>
 * Modified for OCaml from SML: Michael Duggan <md5i@cs.cmu.edu>
 * Modified: Alice Rao <alrao@andrew.cmu.edu>
 *)

-----------------------------------------------------------------------
Welcome to 15-411!
-----------------------------------------------------------------------

This is some starter code for the L1 compiler you have to build for
the Lab1.  It contains a lexer, parser, translator, and even a code
generator, except that the code generator creates pseudo assembly
language with fictitious instructions and an unlimited number of
registers.  We took some care to use good style (according to the
instructor); you may consider this a model for your own coding.  Feel
free to modify any and all of this code as you see fit.

Bug reports to the course staff are particularly welcome and will be
noted in the extra credit category.

-----------------------------------------------------------------------
OCaml Notes
-----------------------------------------------------------------------

This starter code assumes OCaml 4.05.0, the version available on the
autograder. You should ensure that you are using this version by running
`opam switch 4.05.0`. The starter code uses the Jane Street Core standard
library replacement, which you can install using OPAM
<URL:https://opam.ocaml.org/doc/Install.html> with `opam install
core`.

For information on the OCaml Standard Library, ocamllex, ocamlyacc,
and other sundry details, see
<URL:http://caml.inria.fr/pub/docs/manual-ocaml-4.05/index.html>.

------------------------------------------------------------------------
Source Files
------------------------------------------------------------------------

The following are the source files for the L1 compiler

README               -- this file

Makefile             -- makefile for the compiler
                        For a quick test

    % make          (generates file bin/c0c)
    % bin/c0c --verbose ../tests0/return01.l1.

	                should generate ../tests0/test1.s in pseudo assembly

    % make clean        (removes generated files)

bin/c0c              -- the native executable generated by OCaml

top/             Toplevel stuff
  top.ml         This is the main driver.  It calls all the other parts
                 of the compiler.

parse/           lexing and parsing
  ast.ml         abstract syntax tree for the l1 language
  c0Lexer.mll    lexer for l1 (ocamllex file)
  c0Parser.mly   parser for l1 (ocamlyacc file)
  parse.ml       code that sets up and calls the parser/lexer
  parseState.ml  some utility code for the parser

type/            type checking
  typeChecker.ml basic type checker over the ast

trans/           translation to IR
  tree.ml        data structure representing the IR tree
  trans.ml       converts from the AST to the IR tree
  temp.ml        generates temporary variables on the fly

codegen/         conversion to assembly
  assem.ml       representation of assembly used by the compiler
  codegen.ml     generates pseudo-assembly with temporaries from IR

util/
  errorMsg.ml    error message utilities
  mark.ml        library for tracking source file positions
  symbol.ml      symbol table library

graph/
  apply.ml       applies the coloring to assem generated by instruction select
  liveness.ml    analyze the assem to get liveness of temps in lines
  regalloc.ml    generate the coloring from liveness analysis

------------------------------------------------------------------------
Debugging Hints
------------------------------------------------------------------------

"make debug" will generate a debuggable bytecode version of the
compiler named "go.d.byte".  You can run this in the OCaml debugger:

  ocamldebug go.d.byte
  set arguments ../tests0/return01.l1
  step

The debugger is a time-travelling debugger.  It allows you to step
backwards as well as forwards.  See the OCaml manual for more
information.

You can use

  - ./go.d.byte --verbose --dump-ast --dump-ir --dump-assem file.l1;

to print information from all the phases of the current compiler.

You can use

  - ./go.d.byte "--debug-parse file.l1";

to get a debug trace of the parser.

To get a state table for the parser, you can run

  - ocamlyacc -v parse/c0Parser.mly

This will generate a "parse/c0Parser.output" file which contains
information about the parse states.  Remove the generated c0Parser.ml
and c0Parser.mli files before recompiling, as they will confuse
ocamlbuild.  (Try it and see.  It is safe.)



------------------------------------------------------------------------
Lab1 checkpoint
------------------------------------------------------------------------

We finished the register allocation and liveness analysis. The liveness analysis
just covers the straight line part with no other rules working for control flow.
We also finished the register spilling and achieved a pretty good pass rate
with just spilling but would memory overflow in some tests.
As a result, we commit now to just use spilling without register allocation.

The typechecker remained unchanged. We set up a rule for not using r11
in register usage to save it for spilling usage and when we encounter
a temp which should be in stack, we check it and use rbp to find its place.

In addition, MOD and DIV calculation needs eax and ecx to take one of the operand
and store the result after calculation.

------------------------------------------------------------------------
Lab2 checkpoint
------------------------------------------------------------------------

In lab2, we add control logic to the grammar and we also need to modify the
typeChecker.

We also add a lot of operations such as binops, asnops and unops. We did
elaboration process most in the parser level where when we see a for loop or a
asnop operation, we directly elaborate it into a while loop or a binop associated
with binop operation.

We create another label class similar to TEMP which also counts from 0 and tags
all labels in assembly code. Labels are created when we need to translate a
condition or a loop.

Ast tree. -> sequence of statement

TypeChecker

------------------------------------------------------------------------
Lab3 checkpoint
------------------------------------------------------------------------

We transferred the program to a sequence of gdecls and evaluate them separately.

We created another argument class that prioritize register usage from EDI. Since
we reset the counter for TEMPs at the start of every gdecls and register arguments
into environment env before evaluating function body, arguements are automatically
connected to Temps inside function.

In testing, we found out that when we trying to enter a function, rsp need to mod
16 by 8 which should be handled in the caller. Caller saved registers are handled
before function call and callee saved registers are handled after entering the
function.

TypeChecker


------------------------------------------------------------------------
Lab6 checkpoint
------------------------------------------------------------------------

In lab6, we decided to do LLVM project. Since we need to make x86 and llvm work at
the same time, we created a new compile process for llvm starting from trans to
codegen and format. In the counter modules such as temps and struoffsets, we
previously wanted to keep both of them but then we figured out that the struoffset
system is different for x86 and llvm because in llvm we only need to keep track
of the index of each element in a struct instead of computing offset.

Checking exceptions is a very difficult part for us because at first some
of the exception are handled by system such as div by zero. Unlike in x86,
every are stored in register, in llvm we need to know type for everything. This
puts a challenge for checking index out of bound. We figured out that we can
bitcast the pointer to i32* and getelementptr -1 to store length of index and
fetch it later when we want to access it.

The biggest difference between x86 and llvm is the type system. We need to store
what the type is for every single temp. Another big difference is struct definition
that in x86, they are all pointers while in llvm, we need to declare struct types
ahead and even without definition, we need to declare it as opaque.

The extra work we did was floating point number handling and it is described and
implemented in lab6_extra.
